
TASK  
1. JavaScript & TypeScript Mastery
1.1 Async Programming & Event Loop
class limit {
    constructor(limit) {
        this.limit = limit; 
        this.queue = []; 
        this.timestamps = []; 
        this.debounce = new Map(); 
    }

    async schedule(fn, delay) {
        return new Promise((resolve, reject) => {
            const task = async () => {
                try {
                    await new Promise(res => setTimeout(res, delay));

                    const result = await fn();
                    resolve(result);
                } catch (error) {
                    reject(error);
                }
            };

            if (this.debounce.has(fn)) {
                clearTimeout(this.debounce.get(fn));
            }
            const debounceTimeout = setTimeout(() => {
                this.debounce.delete(fn);
                this.queue.push(task);
                this.qeueProcess();
            }, delay);
            this.debounce.set(fn, debounceTimeout);
        });
    }

    qeueProcess() {
        if (this.queue.length === 0) return;

        const now = Date.now();

        // Remove timestamps older than 1 second
        this.timestamps = this.timestamps.filter(ts => now - ts < 1000);

        if (this.timestamps.length < this.limit) {
            // If under the limit, execute the next task
            const task = this.queue.shift();
            this.timestamps.push(now);
            task().finally(() => this.qeueProcess());
        } else {
            // If over the limit, wait and retry
            setTimeout(() => this.qeueProcess(), 100);
        }
    }
}

1.2 Required Keys Utility Type

type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Pick<T, K> ? never : K;
  }[keyof T];

  function validateRequiredKeys<T>(obj: T): obj is Required<Pick<T, RequiredKeys<T>>> {
    return true; 
  }
  type useCase = {
    requiredKey: string;
    optionalKey?: number;
    anotherRequiredKey: boolean;
  };
  
  type Result = RequiredKeys<useCase>; 
  
  const obj1 = {
    requiredKey: "value",
    anotherRequiredKey: true,
  };
  
  const obj2 = {
    optionalKey: 42,
  };
  
  if (validateRequiredKeys<Example>(obj1)) {
    console.log("correct type");
  } else {
    console.log("Missing  types.");
  }

1.3 Function Composition & Closures

  type AnyFunction = (...args: any[]) => any;

function compose<T>(fns: AnyFunction[]): (...args: Parameters<typeof fns[0]>) => Promise<T> {
    return async (...args: any[]) => {
        let result = args;

        for (const fn of fns) {
            result = [await fn(...result)];
        }

        return result[0];
    };
}

// Use Case:

const add = (x: number) => x + 2;

const multiplyAsync = async (x: number) => x * 3;

const subtract = (x: number) => x - 5;

const composedFunction = compose<number>([add, multiplyAsync, subtract]);

(async () => {
    const result = await composedFunction(4);
    console.log(result); 
})();


3. React-Focused Exercises
3.1 Custom Hooks & useMemo/useCallback

import { useState, useEffect, useCallback, useMemo } from 'react';

const cache = new Map(); 

const useFetchWithCache = (url) => {
    const [data, setData] = useState(null);
    const [error, setError] = useState(null);
    const [loading, setLoading] = useState(false);

    const fetchData = useCallback(async () => {
        if (!url) return;

        if (cache.has(url)) {
            setData(cache.get(url));
            return;
        }

        setLoading(true);
        setError(null);

        try {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`Error: ${response.statusText}`);
            }
            const result = await response.json();

            cache.set(url, result);
            setData(result);
        } catch (err) {
            setError(err.message);
        } finally {
            setLoading(false);
        }
    }, [url]);

    useEffect(() => {
        fetchData();
    }, [fetchData]);

    return useMemo(() => ({ data, error, loading }), [data, error, loading]);
};

export default useFetchWithCache;


3.2 Performance Optimization & Virtualized Lists:
will use react-window  to achieve this.
Steps:
1. Install react-window: npm install react-window

import React, { useCallback } from 'react';
import { FixedSizeList as List } from 'react-window';

const ListItem = React.memo(({ index, style }) => {
    return (
        <div style={style}>
            Item #{index}
        </div>
    );
});

const VirtualizedList = () => {
    const itemCount = 10000; 
    const itemHeight = 35; 

    const renderRow = useCallback(({ index, style }) => {
        return <ListItem index={index} style={style} />;
    }, []);

    return (
        <List
            height={500} 
            itemCount={itemCount}
            itemSize={itemHeight}
            width="100%"
        >
            {renderRow}
        </List>
    );
};

export default VirtualizedList;
replace  VirtualizedList with your component:

import React from 'react';
import VirtualizedList from './VirtualizedList';

const App = () => {
    return (
        <div>
            <h1>Virtualized List Example</h1>
            <VirtualizedList />
        </div>
    );
};

export default App;


3.3 Higher-Order Components (HoC):

Step 1: Create the withErrorBoundary Higer Order Component
import React, { Component } from 'react';

const withErrorBoundary = (WrappedComponent, FallbackComponent) => {
    return class ErrorBoundary extends Component {
        constructor(props) {
            super(props);
            this.state = {
                hasError: false,
                error: null,
            };
        }

        static getDerivedStateFromError(error) {
            // Update state to show fallback UI
            return { hasError: true, error };
        }

        componentDidCatch(error, errorInfo) {
            // Log the error (e.g., to an error reporting service)
            console.error('Error caught by ErrorBoundary:', error, errorInfo);
        }

        handleRetry = () => {
            // Reset error state and retry rendering
            this.setState({ hasError: false, error: null });
        };

        render() {
            const { hasError, error } = this.state;

            if (hasError) {
                // Render the fallback UI
                return (
                    <FallbackComponent
                        error={error}
                        onRetry={this.handleRetry}
                    />
                );
            }

            // Render the wrapped component
            return <WrappedComponent {...this.props} />;
        }
    };
};

export default withErrorBoundary;


Step 2: Create a Fallback Component

import React from 'react';

const FallbackUI = ({ error, onRetry }) => {
    return (
        <div style={{ textAlign: 'center', padding: '20px' }}>
            <h2>Something went wrong.</h2>
            {error && <p style={{ color: 'red' }}>{error.message}</p>}
            <button onClick={onRetry} style={{ marginTop: '10px' }}>
                Retry
            </button>
        </div>
    );
};

export default FallbackUI;


Step 3: Use the withErrorBoundary HoC

import React from 'react';
import VirtualizedList from './VirtualizedList';
import withErrorBoundary from '../hoc/withErrorBoundary';
import FallbackUI from './FallbackUI';

const App = () => {
    return (
        <div>
            <h1>Virtualized List Example</h1>
            <VirtualizedList />
        </div>
    );
};

export default withErrorBoundary(App, FallbackUI);

4. End-to-End Frontend Integration
4.1 Micro-Frontend Router Strategy
 step-1 install react-router-dom used to achieve this.
    npm install react-router-dom
Step-2: define routes and lazy loading:
import React, { Suspense } from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';

// Lazy-load micro-frontends
const MicroFrontendA = React.lazy(() => import('microfrontendA/App'));
const MicroFrontendB = React.lazy(() => import('microfrontendB/App'));

const ShellApp = () => {
    return (
        <Router>
            <div>
                <h1>Micro-Frontend Shell</h1>
                <nav>
                    <ul>
                        <li><a href="/microfrontend-a">Micro-Frontend A</a></li>
                        <li><a href="/microfrontend-b">Micro-Frontend B</a></li>
                    </ul>
                </nav>
                <Suspense fallback={<div>Loading...</div>}>
                    <Routes>
                        <Route path="/microfrontend-a" element={<MicroFrontendA />} />
                        <Route path="/microfrontend-b" element={<MicroFrontendB />} />
                    </Routes>
                </Suspense>
            </div>
        </Router>
    );
};

export default ShellApp;

// Step 3: Micro-Frontend A
import React from 'react';

const App = () => {
    return <div>Welcome to Micro-Frontend A</div>;
};

export default App;
// Step 4: Micro-Frontend B
import React from 'react';

const App = () => {
    return <div>Welcome to Micro-Frontend B</div>;
};

export default App;
//step 5: Expose Micro-Frontends
// Webpack Configuration
const ModuleFederationPlugin = require('webpack').container.ModuleFederationPlugin;

module.exports = {
    plugins: [
        new ModuleFederationPlugin({
            name: 'shell',
            remotes: {
                microfrontendA: 'microfrontendA@http://localhost:3001/remoteEntry.js',
                microfrontendB: 'microfrontendB@http://localhost:3002/remoteEntry.js',
            },
        }),
    ],
};
//Micro-Frontend A Webpack Configuration

const ModuleFederationPlugin = require('webpack').container.ModuleFederationPlugin;

module.exports = {
    plugins: [
        new ModuleFederationPlugin({
            name: 'microfrontendA',
            filename: 'remoteEntry.js',
            exposes: {
                './App': './src/App',
            },
        }),
    ],
};
//Micro-Frontend B Webpack Configuration

const ModuleFederationPlugin = require('webpack').container.ModuleFederationPlugin;

module.exports = {
    plugins: [
        new ModuleFederationPlugin({
            name: 'microfrontendA',
            filename: 'remoteEntry.js',
            exposes: {
                './App': './src/App',
            },
        }),
    ],
};
